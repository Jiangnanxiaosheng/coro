# namespace coro

#### **什么是协程？**

协程是一种特殊的函数，它可以在执行过程中 挂起（suspend） 并稍后 恢复（resume），而不丢失当前的执行状态。相比于传统的函数调用，协程允许 非阻塞式编程，特别适用于 异步任务（async tasks） 和 生成器（generators）。

#### **为什么需要协程？**

在 C++20 之前，我们一般使用 回调（callbacks） 或 `std::future` + `std::thread` 处理异步任务，但是这些方法存在：

- 回调嵌套过深（callback hell）
- `std::future` 只能 `get()` 一次，且不支持 `await` 语法
- `std::thread` 创建成本高

协程可以用更直观的方式表达异步逻辑，避免回调地狱，提高可读性。

#### **如何定义一个协程？**

一个协程必须返回一个特殊的类型，如下文 `Task<T>`，并且要用 `co_await`、`co_yield`、`co_return` 语句：

```cpp
Task<int> myCoroutine() {
    co_return 42; // 返回 42
}
```

编译器会将 `co_return` 转换为对 `Promise<T>::return_value(42)` 的调用。

## 协程基础概念 && 用户自定义类型Task

C++20 规定了三个协程关键字：

- **co_await**：用于等待一个异步操作。当协程执行到 co_await 时，它会暂停执行，直到等待的操作完成后恢复执行。
- **co_yield**：用于生成一个值并暂时挂起协程。类似于 Python 生成器中的 yield，它允许协程产生多个值。
- **co_return**：用于返回协程的最终结果，并结束协程的执行。

在函数中出现 `co_await`、`co_yield` 或 `co_return` 关键字时，编译器会将该函数识别为协程。


### 协程句柄 (std::coroutine_handle)

协程系统涉及多个核心数据类型，其中最重要的是 **协程句柄**（`std::coroutine_handle`）。协程句柄是协程实例的抽象表示，它封装了协程的所有内部变量和执行状态，并提供了对协程的控制能力。其主要方法包括：

- **resume()**：启动或恢复协程的执行。
- **done()**：判断协程是否已经完成。
- **destroy()**：销毁协程，释放相关资源。


### promise_type

当我们定义一个返回类型为 `Task` 的协程时，编译器会查找其对应的 **promise_type**。`promise_type` 是一个用户定义的类型，负责管理协程的状态和返回值。每个协程都关联着一个 `promise_type` 实例。

`promise_type` 需要实现以下成员函数，编译器会在适当的时机调用它们：

- **get_return_object()**：返回协程的结果对象（通常是一个封装了 coroutine_handle 的对象）。
- **initial_suspend()**：决定协程在启动时是否立即挂起。
- **final_suspend()**：决定协程执行完毕后是否挂起等待清理。
- **return_value(T value) / return_void()**：设置协程的返回值。
- **unhandled_exception()**：处理协程中的未捕获异常。

### 示例代码

```cpp
#include <coroutine>
#include <iostream>
#include <optional>

// 代表一个可以被等待的任务
template <typename T> struct Task {
    struct promise_type {
        std::optional<T> value;

        // 返回一个包含协程句柄的任务对象
        Task get_return_object() {
            return Task{std::coroutine_handle<promise_type>::from_promise(*this)};
        }

        std::suspend_always initial_suspend() { return {}; }        // 协程启动时先挂起
        std::suspend_always final_suspend() noexcept { return {}; } // 协程结束时挂起等待清理

        void unhandled_exception() { std::terminate(); } // 未捕获的异常导致程序终止

        void return_value(T v) { value = v; }
    };

    std::coroutine_handle<promise_type> handle;

    Task(std::coroutine_handle<promise_type> h) : handle(h) {}
    ~Task() {
        if (handle)
            handle.destroy();
    }

    // 获取协程的结果
    T get() { return handle.promise().value.value(); }
};


// 使用协程的函数，返回一个 Task<int>
Task<int> function() {
    std::cout << "开始执行function...\n";
    co_return 100;
}

int main() {
    std::cout << "开始构建task\n";
    auto task = function();
    std::cout << "构建task完成\n";
    while (!task.handle.done()) {
        task.handle.resume();
        int result = task.get(); // 获取协程的返回结果
        std::cout << "结果为 : " << result << std::endl;
    }
    return 0;
}
```

**运行结果：**

```
构建 task
task 构建完成
开始执行 function()...
结果为: 100
```


### initial_suspend() 与 final_suspend()

`initial_suspend()` 用于决定协程在启动时是否立即执行。

- 返回 std::suspend_always{} → **协程启动时先挂起**，需显式 resume() 。
- 返回 std::suspend_never{} → **协程立即执行**。

在上面的示例中，由于 `initial_suspend()` 返回 `std::suspend_always{}`，执行 `auto task = function();` 时，协程不会立刻运行，而是在 `resume()` 被调用后才开始执行。

`final_suspend()` 用于决定协程结束后是否挂起等待销毁。

- 返回 std::suspend_always{} → 让调用者手动销毁协程。
- 返回 std::suspend_never{} → 结束后立即释放协程资源。


### awaitable（可等待对象）与 awaiter（等待体）


`awaitable` 是可以被 `co_await` 等待的对象，而 `awaiter` 是具体实现 `awaitable` 行为的对象。

`awaiter` 需要实现以下接口：

- **await_ready()**：返回 true 表示无需挂起，直接恢复执行；返回 false 表示需要挂起。
- **await_suspend(std::coroutine_handle<>)**：当协程挂起时调用。可以注册回调或存储协程句柄。
- **await_resume()**：当协程恢复时调用，返回 `co_await` 语句的结果。


### 协程执行流程总结

1. **创建 promise_type 实例**：在 get_return_object() 里构造协程返回对象。
2. **调用 initial_suspend()**：决定是否立即运行协程。
3. **执行协程体**：

- 遇到 `co_await`：

    调用 `await_ready()` 判断是否立即恢复。如果挂起，执行 `await_suspend()`，然后等待 `resume()`。恢复后执行 `await_resume()`。

- 遇到 `co_yield` 生成值并挂起。
- 遇到 `co_return` 结束协程。

4. **调用 final_suspend()**：决定是否自动销毁协程。



## sync_wait
`sync_wait` 在协程上下文之外使用，阻塞调用线程，同步等待协程执行完毕。

可以在调用线程上执行协程或在`ThreadPoll`以及`IoScheduler`内执行协程。

```cpp
#include <coro/coro.hpp>
#include <iostream>


int main() {
   
    auto make_num_double_task = [](int x) -> coro::Task<int> { co_return x + x; };
    
    // 这行代码会阻塞主线程直到 make_num_double_task(5) 完成
    auto result = coro::sync_wait(make_num_double_task(5));
    std::cout << "Result = " << result << "\n";

    // 创建具有2个工作线程的线程池
    coro::ThreadPool tp(2);

    auto make_task_offload = [](coro::ThreadPool& tp, int x) -> coro::Task<int> {
        co_await tp.schedule(); // 将任务分发到线程池进行处理
        co_return x + x;        // 这行代码会在线程池的工作线程上执行
    };
    
    // 依然会阻塞调用线程即主线程直到任务完成，但是任务会分发到线程池内执行
    result = coro::sync_wait(make_task_offload(tp, 10));
    std::cout << "Offload Result = " << result << "\n";
}
```

`sync_wait`的实现原理大致如下：
```
auto sync_wait(Task<T> task) {
    std::condition_variable cv;
    bool done = false;
    
    task.set_done_callback([&]() {
        std::lock_guard<std::mutex> lock(mutex);
        done = true;
        cv.notify_one();
    });

    task.resume();  // 在sync_wait内恢复协程

    // 等待协程任务完成
    std::unique_lock<std::mutex> lock(mutex);
    cv.wait(lock, [&] { return done; });

    return task.promise().result();
}
```
上面的代码只是伪代码，实际上利用 `final_suspend()` 不需要额外的回调函数。

这种 `sync_wait` 适用于无 I/O 阻塞的简单任务，如果是异步任务（例如 co_await 网络请求），则需要额外的调度器来管理。

## when_all



## ThreadPool



## Poll



## IoScheduler

